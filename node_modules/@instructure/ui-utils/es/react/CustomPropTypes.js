var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import React from 'react';
import PropTypes from 'prop-types';

import getDisplayName from './getDisplayName';
import canUseDOM from '../dom/canUseDOM';

/**
 * ---
 * category: utilities/react
 * ---
 * Custom prop types for React components.
 * @module CustomPropTypes
 */
export default {
  Children: {
    /**
     *
     * Validate that the children of a component is one of the specified types.
     *
     * ```js
     *  class Example extends Component {
     *    static propTypes = {
     *      children: CustomPropTypes.Children.oneOf([Foo, Bar, Baz])
     *    }
     *
     *    render () {
     *      return <div>{this.props.children}</div>
     *    }
     *  }
     * ```
     *
     * This will allow children such as:
     *
     * ```jsx
     *  <Example>
     *    <Foo />
     *  </Example>
     * ```
     *
     *  OR
     *
     * ```jsx
     *  <Example>
     *    <Bar />
     *    <Foo />
     *  </Example>
     * ```
     *
     * But will fail on something like:
     *
     * ```jsx
     *  <Example>
     *    <h1>Example</h1>
     *    <Foo />
     *  </Example>
     * ```
     * @returns {Error} if validation failed
     */
    oneOf: function oneOf(validTypes) {
      return function (props, propName, componentName) {
        var children = React.Children.toArray(props[propName]);
        var validTypeNames = validTypes.map(function (type) {
          return getDisplayName(type);
        });

        for (var i = 0; i < children.length; i++) {
          var childName = getDisplayName(children[i].type);

          if (validTypeNames.indexOf(childName) < 0) {
            return new Error('Expected one of ' + validTypeNames.join(', ') + ' in ' + componentName + ' but found \'' + childName + '\'');
          }
        }
      };
    },


    /**
     *
     * Ensures that there is exactly one of each specified child
     *
     * ```js
     *  class Example extends Component {
     *    static propTypes = {
     *      children: CustomPropTypes.Children.oneOfEach([Foo, Bar, Baz])
     *    }
     *
     *    render () {
     *      return <div>{this.props.children}</div>
     *    }
     *  }
     * ```
     *
     * This will enforce the following:
     *
     * ```jsx
     *  <Example>
     *    <Foo />
     *    <Bar />
     *    <Baz />
     *  </Example>
     * ```
     * An error will be thrown
     *  - If any of the children are not provided (ex. Foo, Bar, but missing Baz)
     *  - If multiple children of the same type are provided (ex. Foo, Foo, Bar, and Baz)
     *
     * @param {Array} validTypes - Array of child types
     * @returns {Error} if validation failed
     */
    oneOfEach: function oneOfEach(validTypes) {
      return function (props, propName, componentName) {
        var children = React.Children.toArray(props[propName]);
        var instanceCount = {};
        var validTypeNames = validTypes.map(function (type) {
          var typeName = getDisplayName(type);
          instanceCount[typeName] = 0;
          return typeName;
        });

        for (var i = 0; i < children.length; i++) {
          var childName = getDisplayName(children[i].type);

          if (validTypeNames.indexOf(childName) < 0) {
            return new Error('Expected one of ' + validTypeNames.join(', ') + ' in ' + componentName + ' but found \'' + childName + '\'');
          }

          instanceCount[childName] = (instanceCount[childName] || 0) + 1;
        }

        var errors = [];
        Object.keys(instanceCount).forEach(function (childName) {
          if (instanceCount[childName] > 1) {
            errors.push(instanceCount[childName] + ' children of type ' + childName);
          }
          if (instanceCount[childName] === 0) {
            errors.push('0 children of type ' + childName);
          }
        });

        if (errors.length > 0) {
          return new Error('Expected exactly one of each ' + validTypeNames.join(', ') + ' in ' + componentName + ' but found:\n' + errors.join('\n'));
        }
      };
    },


    /**
     *
     * Validate the type and order of children for a component.
     *
     * ```js
     *  class Example extends Component {
     *    static propTypes = {
     *      children: CustomPropTypes.Children.requireOrder([Foo, Bar, Baz])
     *    }
     *
     *    render () {
     *      return <div>{this.props.children}</div>
     *    }
     *  }
     * ```
     *
     * This will enforce the following:
     *
     * ```jsx
     *  <Example>
     *    <Foo />
     *    <Bar />
     *    <Baz />
     *  </Example>
     * ```
     *
     * This validator will also allow various permutations of the order.
     *
     * ```js
     *  class Example extends Component {
     *    static propTypes = {
     *      children: CustomPropTypes.Children.requireOrder(
     *        [Foo, Bar, Baz],
     *        [Foo, Bar],
     *        [Bar, Baz],
     *      )
     *    }
     *
     *    render () {
     *      return <div>{this.props.children}</div>
     *    }
     *  }
     * ```
     *
     * This will enforce one of the following:
     *
     * ```jsx
     *  <Example>
     *    <Foo />
     *    <Bar />
     *    <Baz />
     *  </Example>
     * ```
     *
     *  OR
     *
     * ```jsx
     *  <Example>
     *    <Foo />
     *    <Bar />
     *  </Example>
     * ```
     *
     *  OR
     *
     * ```jsx
     *  <Example>
     *    <Bar />
     *    <Baz />
     *  </Example>
     * ```
     *
     * @param {...Array} validTypeGroups One or more Arrays of valid types
     * @returns {Error} if validation failed
     */
    enforceOrder: function enforceOrder() {
      for (var _len = arguments.length, validTypeGroups = Array(_len), _key = 0; _key < _len; _key++) {
        validTypeGroups[_key] = arguments[_key];
      }

      function validateTypes(childNames, typeNames) {
        for (var i = 0; i < childNames.length; i++) {
          if (childNames[i] !== typeNames[i]) {
            return false;
          }
        }

        return true;
      }

      function formatGroupTypes(componentName, typeGroups) {
        return typeGroups.map(function (types) {
          return formatTypes(componentName, types);
        }).join('\n\n');
      }

      function formatTypes(componentName, types) {
        var children = types.map(function (type) {
          return getDisplayName(type);
        }).map(function (name) {
          return '  <' + name + ' />';
        }).join('\n');

        return '<' + componentName + '>\n' + children + '\n</' + componentName + '>';
      }

      return function (props, propName, componentName) {
        var childNames = React.Children.toArray(props[propName]).map(function (child) {
          return getDisplayName(child.type);
        });

        // Validate each group, if any of them are valid we're done
        for (var i = 0; i < validTypeGroups.length; i++) {
          var validTypeNames = validTypeGroups[i].map(function (type) {
            return getDisplayName(type);
          });

          if (validateTypes(childNames, validTypeNames)) {
            return;
          }
        }

        // If we make it through the loop then children are not valid
        return new Error('Expected children of ' + componentName + ' in one of the following formats:\n' + formatGroupTypes(componentName, validTypeGroups) + '\n\n\nInstead of:\n' + formatTypes(componentName, childNames));
      };
    }
  },

  /**
   * Ensure that a corresponding handler function is provided for the given prop if the
   * component does not manage its own state.
   *
   * ```js
   *  class Foo extends Component {
   *    static propTypes = {
   *      selected: CustomPropTypes.controllable(PropTypes.bool, 'onSelect', 'defaultSelected'),
   *      onSelect: PropTypes.func,
   *      defaultSelected: PropTypes.bool
   *    }
   *  ...
   * ```
   *
   * This will throw an error if the 'selected' prop is supplied without a corresponding
   * 'onSelect' handler and will recommend using 'defaultSelected' instead.
   *
   * @param {function} propType - validates the prop type. Returns null if valid, error otherwise
   * @param {string} handlerName - name of the handler function
   * @param {string} defaultPropName - name of the default prop
   * @returns {Error} if designated prop is supplied without a corresponding handler function
   */
  controllable: function controllable(propType) {
    var handlerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'onChange';
    var defaultPropName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'defaultValue';

    return function (props, propName, componentName) {
      var error = propType.apply(null, arguments);
      if (error) {
        return error;
      }

      if (props[propName] && typeof props[handlerName] !== 'function') {
        return new Error(['You provided a \'' + propName + '\' prop without an \'' + handlerName + '\' handler on \'' + componentName + '\'. This will render a controlled component. If the component should be uncontrolled and manage its own state, use \'' + defaultPropName + '\'. Otherwise, set \'' + handlerName + '\'.'].join(''));
      }
    };
  },


  /**
   * Verify that the given prop is a valid React element.
   *
   * @param {Object} props - object containing the component props
   * @param {string} propName - name of the given prop
   * @param {string} componentName - name of the component
   * @param {string} location
   * @param {string} propFullName
   * @returns {Error} if prop is an invalid react element
   */
  elementType: function elementType(props, propName, componentName, location, propFullName) {
    if (typeof props[propName] === 'undefined') {
      return;
    }

    var propValue = props[propName];
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);

    if (React.isValidElement(propValue)) {
      return new Error('Invalid ' + location + ' `' + propFullName + '` of type ReactElement supplied to `' + componentName + '`, expected ' + 'an element type (a string or a ReactClass).');
    }

    if (propType !== 'function' && propType !== 'string') {
      return new Error('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` supplied to `' + componentName + '`, ' + 'expected an element type (a string or a ReactClass).');
    }
  },


  element: canUseDOM ? PropTypes.oneOfType([PropTypes.element, PropTypes.instanceOf(Element)]) : PropTypes.element,

  /**
   * Verify that a prop cannot be given if one or more other props are also
   * given.
   *
   * ```js
   *  class Foo extends Component {
   *    static propTypes = {
   *      decimalPrecision: CustomPropTypes.xor(PropTypes.number, 'significantDigits'),
   *      significantDigits: CustomPropTypes.xor(PropTypes.number, 'decimalPrecision')
   *    }
   *  ...
   * ```
   *
   * This will throw an error if both the `decimalPrecision` and
   * `significantDigits` props are provided.
   *
   * @param {function} propType - validates the prop type. Returns null if valid, error otherwise
   * @param {...string} otherPropNames - reject if any of these other props are also given
   * @returns {Error} if any of the other props are also given
   */
  xor: function xor(propType) {
    for (var _len2 = arguments.length, otherPropNames = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      otherPropNames[_key2 - 1] = arguments[_key2];
    }

    return function (props, propName, componentName) {
      if (props[propName] != null) {
        var otherProps = otherPropNames.map(function (name) {
          return props[name];
        }).filter(function (prop) {
          return prop != null;
        });
        if (otherProps.length > 0) {
          return new Error('Invalid prop `' + propName + '` supplied to `' + componentName + '`: expected only one of ' + ([propName].concat(otherPropNames).map(function (name) {
            return '`' + name + '`';
          }).join(', ') + ' to be set.'));
        }
      }

      return propType.apply(null, arguments);
    };
  }
};