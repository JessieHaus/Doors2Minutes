var _class, _temp;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import FocusRegion from './FocusRegion';

var ENTRIES = [];

/**
 * ---
 * category: utilities/a11y
 * ---
 * @module FocusManager
 * Class for focus operations.
 * - Scoping focus within a given context,
 * - Mark active element for focus later
 * - Return focus to the marked element
 */
var FocusRegionManager = (_temp = _class = function FocusRegionManager() {
  _classCallCheck(this, FocusRegionManager);
}, _class.focusRegion = function (element, options) {
  var region = new FocusRegion(element, options);
  var activeEntry = FocusRegionManager.getActiveEntry();

  ENTRIES.forEach(function (_ref) {
    var region = _ref.region;

    region && region.teardown();
  });

  region.setup();
  region.focus();

  var entry = {
    id: region.id,
    element: element,
    region: region,
    children: [],
    parent: activeEntry
  };

  ENTRIES.push(entry);

  if (activeEntry) {
    activeEntry.children.push(entry);
  }

  return region;
}, _class.getActiveEntry = function () {
  return ENTRIES.find(function (_ref2) {
    var region = _ref2.region;
    return region.focused;
  });
}, _class.removeEntry = function (element, id) {
  var index = void 0;
  if (id) {
    index = ENTRIES.findIndex(function (entry) {
      return entry.id === id;
    });
  } else {
    index = ENTRIES.findIndex(function (entry) {
      return entry.element === element;
    });
  }
  var entry = ENTRIES[index];

  if (index > -1) {
    ENTRIES.splice(index, 1);
  }

  return entry;
}, _class.isFocused = function (element, id) {
  var entry = FocusRegionManager.getActiveEntry();
  if (id) {
    return entry && entry.region && entry.id === id;
  } else {
    return entry && entry.region && entry.element === element;
  }
}, _class.clearEntries = function () {
  ENTRIES = [];
}, _class.blurRegion = function (element, id) {
  var entry = FocusRegionManager.removeEntry(element, id);

  if (entry) {
    var children = entry.children,
        region = entry.region,
        parent = entry.parent;

    // teardown the region...

    region && region.teardown();

    // and any regions created from it
    if (children) {
      children.forEach(function (_ref3) {
        var id = _ref3.id,
            element = _ref3.element;

        var entry = FocusRegionManager.removeEntry(element, id);
        entry && entry.region && entry.region.teardown();
      });
    }

    // setup the region's parent if it exists
    parent && parent.region && parent.region.setup();

    region && region.blur(); // this should focus the parent region
  }
}, _temp);
export { FocusRegionManager as default };