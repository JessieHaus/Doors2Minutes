var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * ---
 * category: utilities/a11y
 * ---
 * @module ScreenReaderFocusRegion
 * Utility that hides all DOM elements outside of a specified node. Used,
 * for example, in overlay components where we want to restrict the screen
 * readers to the overlay content
 */
var ScreenReaderFocusRegion = function () {
  function ScreenReaderFocusRegion(element) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      shouldContainFocus: true,
      liveRegion: []
    };

    _classCallCheck(this, ScreenReaderFocusRegion);

    this._observer = null;
    this._attributes = [];
    this._nodes = [];
    this._parents = [];

    this.handleDOMMutation = function (records) {
      records.forEach(function (record) {
        Array.from(record.addedNodes).forEach(function (addedNode) {
          _this.hideNode(addedNode);
        });

        record.removedNodes.forEach(function (removedNode) {
          // Node has been removed from the DOM, make sure it is
          // removed from our list of hidden nodes as well
          var index = _this._nodes.indexOf(removedNode);
          if (index >= 0) {
            _this._nodes.splice(index, 1);
          }
        });
      });
    };

    this._liveRegion = Array.isArray(options.liveRegion) ? options.liveRegion : [options.liveRegion];
    this._contextElement = element;
    this._options = options;
  }

  _createClass(ScreenReaderFocusRegion, [{
    key: 'updateElement',
    value: function updateElement(element) {
      this._contextElement = element;
    }
  }, {
    key: 'muteNode',
    value: function muteNode(node) {
      var _this2 = this;

      if (node) {
        // When we are trapping screen reader focus on an element that
        // is deep inside the DOM, we can't apply aria-hidden to the
        // parents, so parent regions will be read if they have a role
        // and/or aria-label assigned. To optimize SR ux we remove the role,
        // aria-label, and aria-hidden attrs temporarily when the region
        // is focused, and then we restore them when focus is lost.
        ['role', 'aria-label', 'aria-hidden' // this should never happen right?
        ].forEach(function (attribute) {
          var value = node.getAttribute(attribute);

          if (value !== null) {
            _this2._attributes.push([node, attribute, value]);
            node.removeAttribute(attribute);
          }
        });

        this._observer.observe(node, { childList: true });
      }
    }
  }, {
    key: 'hideNode',
    value: function hideNode(node) {
      if (node && node.nodeType === 1 && node !== this._contextElement && node.getAttribute('aria-hidden') !== 'true' && this._parents.indexOf(node) === -1 && this._nodes.indexOf(node) === -1 && this._liveRegion.indexOf(node) === -1) {
        node.setAttribute('aria-hidden', 'true');
        this._nodes.push(node);
      }
    }
  }, {
    key: 'setup',
    value: function setup() {
      var _this3 = this;

      if (!this._options.shouldContainFocus) {
        return;
      }

      this._observer = new MutationObserver(this.handleDOMMutation);

      var node = this._contextElement;

      while (node && node.nodeType === 1 && node.tagName !== 'BODY') {
        var parent = node.parentElement; // can be null

        if (parent) {
          this._parents.push(parent);

          this.muteNode(parent);

          Array.prototype.slice.call(parent.childNodes).forEach(function (child) {
            _this3.hideNode(child);
          });
        }

        node = node.parentNode; // should never be null, will default to doc element
      }
    }
  }, {
    key: 'teardown',
    value: function teardown() {
      if (this._observer) {
        this._observer.disconnect();
        this._observer = null;
      }

      this._nodes.forEach(function (node) {
        node.removeAttribute('aria-hidden');
      });
      this._nodes = [];

      this._attributes.forEach(function (attribute) {
        attribute[0].setAttribute(attribute[1], attribute[2] || '');
      });
      this._attributes = [];

      this._parents = [];
    }
  }]);

  return ScreenReaderFocusRegion;
}();

export { ScreenReaderFocusRegion as default };