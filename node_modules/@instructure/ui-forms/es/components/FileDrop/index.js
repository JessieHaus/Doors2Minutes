var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _class, _class2, _temp;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';

import View from '@instructure/ui-layout/lib/components/View';
import themeable from '@instructure/ui-themeable';
import { omitProps } from '@instructure/ui-utils/lib/react/passthroughProps';
import generateElementId from '@instructure/ui-utils/lib/dom/generateElementId';
import keycode from 'keycode';

import FormPropTypes from '../../utils/FormPropTypes';
import FormFieldMessages from '../FormField/FormFieldMessages';

var styles = {
  template: function template(theme) {
    var tmpl = function tmpl() {
      return '/*  imported from styles.css  */\n\n/* stylelint-disable selector-max-class */\n.g7XQl-- {\n  position: relative;\n}\n\n._3PJN9jz {\n  display: block;\n  box-sizing: border-box;\n  position: relative;\n}\n\n._2Kacv1r {\n  width: 0.0625rem;\n  height: 0.0625rem;\n  margin: -0.0625rem;\n  padding: 0;\n  position: absolute;\n  overflow: hidden;\n  clip: rect(0 0 0 0);\n  border: 0;\n}\n\n._3oaMxNS {\n  display: block;\n  box-sizing: border-box;\n  position: relative;\n  /* stylelint-disable-next-line scale-unlimited/declaration-strict-value */\n  z-index: 1;\n  text-align: center;\n  border-radius: ' + theme.borderRadius + ';\n  border: ' + theme.borderWidth + ' ' + theme.borderStyle + ' transparent;\n  cursor: pointer;\n}\n\n[dir="ltr"] ._3oaMxNS {\n  text-align: center;\n}\n\n[dir="rtl"] ._3oaMxNS {\n  text-align: center;\n}\n\n._3oaMxNS:hover {\n    border-color: ' + theme.hoverBorderColor + ';\n  }\n\n._3oaMxNS::before {\n    content: "";\n    position: absolute;\n    top: -0.25rem;\n    left: -0.25rem; /* stylelint-disable-line property-blacklist */\n    right: -0.25rem; /* stylelint-disable-line property-blacklist */\n    bottom: -0.25rem;\n    border: ' + theme.focusBorderWidth + ' ' + theme.focusBorderStyle + ' ' + theme.focusBorderColor + ';\n    border-radius: ' + theme.borderRadius + ';\n    opacity: 0;\n    transform: scale(0.01);\n    transition: all 0.2s;\n    pointer-events: none;\n  }\n\n._1Dw_xzs {\n  display: block;\n  overflow: hidden;\n  border-radius: ' + theme.borderRadius + ';\n}\n\n._1ueT6CI ._3oaMxNS::before {\n    opacity: 1;\n    transform: scale(1);\n  }\n\n._1k7SHGs ._3oaMxNS {\n    border-color: ' + theme.acceptedColor + ';\n  }\n\n._1k7SHGs._1ueT6CI ._3oaMxNS::before {\n      border-color: ' + theme.acceptedColor + ';\n    }\n\n._3bqpP7q ._3oaMxNS {\n    border-color: ' + theme.rejectedColor + ';\n  }\n\n._3bqpP7q._1ueT6CI ._3oaMxNS::before {\n      border-color: ' + theme.rejectedColor + ';\n    }\n\n/* stylelint-enable selector-max-class */\n';
    };

    return tmpl.call(theme, theme);
  },
  'root': 'g7XQl--',
  'label': '_3PJN9jz',
  'input': '_2Kacv1r',
  'labelContent': '_3oaMxNS',
  'layout': '_1Dw_xzs',
  'focused': '_1ueT6CI',
  'dragAccepted': '_1k7SHGs',
  'dragRejected': '_3bqpP7q'
};

import theme from './theme';

function keyEventIsClickButton(e) {
  return e.keyCode === keycode.codes.space || e.keyCode === keycode.codes.enter;
}

// Used try-catch due to missing document/navigator references in Jenkins
function isBrowserMS() {
  var result = false;
  try {
    result = document.documentMode || /Edge/.test(navigator.userAgent);
  } catch (e) {} // eslint-disable-line no-empty

  return result;
}

function getAcceptList(accept) {
  var list = Array.isArray(accept) ? accept : accept.split(',');
  return list.map(function (a) {
    return a.trim().replace(/^\w+$/, '.$&');
  });
}

export function getEventFiles(event, inputEl) {
  var dt = event.dataTransfer;

  if (dt) {
    if (dt.files && dt.files.length) {
      return dt.files;
    } else if (dt.items && dt.items.length) {
      return dt.items;
    }
  } else if (inputEl && inputEl.files) {
    return inputEl.files;
  }

  return [];
}

export function accepts(file, acceptProp) {
  if (file && acceptProp && file.type !== 'application/x-moz-file') {
    var acceptList = getAcceptList(acceptProp);
    var mimeType = file.type || '';
    var baseMimeType = mimeType.replace(/\/.*$/, '');

    return acceptList.some(function (type) {
      if (type.charAt(0) === '.') {
        // type is an extension like .pdf
        if (!file.name) {
          return mimeType.endsWith(type.slice(1));
        }
        return file.name.toLowerCase().endsWith(type.toLowerCase());
      } else if (/\/\*$/.test(type)) {
        // type is something like a image/* mime type
        return baseMimeType === type.replace(/\/.*$/, '');
      }
      return mimeType === type;
    });
  }
  return true;
}

var IS_MS = isBrowserMS();

/**
---
category: components/forms
---
**/
var FileDrop = (_dec = themeable(theme, styles), _dec(_class = (_temp = _class2 = function (_Component) {
  _inherits(FileDrop, _Component);

  function FileDrop(props) {
    _classCallCheck(this, FileDrop);

    var _this = _possibleConstructorReturn(this, (FileDrop.__proto__ || Object.getPrototypeOf(FileDrop)).call(this, props));

    _this.state = {
      isDragAccepted: false,
      isDragRejected: false,
      focused: false
    };
    _this.enterCounter = 0;
    _this.fileInputEl = null;
    _this.defaultId = null;

    _this.handleDragEnter = function (e) {
      e.preventDefault();

      // Count the dropzone and any children that are entered.
      _this.enterCounter += 1;

      // Don't trigger onDragEnter for each children after the first one
      if (_this.enterCounter > 1) {
        return;
      }

      var allFilesAccepted = _this.allFilesAccepted(_this.getDataTransferItems(e));

      _this.setState({
        isDragAccepted: allFilesAccepted,
        isDragRejected: !allFilesAccepted
      });

      _this.props.onDragEnter(e);
    };

    _this.handleDragOver = function (e) {
      e.preventDefault();
      e.stopPropagation();

      try {
        var event = e;
        event.dataTransfer.dropEffect = 'copy';
      } catch (err) {
        // continue regardless of error
      }

      _this.props.onDragOver(e);

      return false;
    };

    _this.handleDragLeave = function (e) {
      e.preventDefault();
      _this.enterCounter -= 1;

      // Only deactivate once the dropzone and all children was left
      if (_this.enterCounter > 0) {
        return;
      }

      _this.setState({
        isDragAccepted: false,
        isDragRejected: false
      });

      _this.props.onDragLeave(e);
    };

    _this.handleDrop = function (e) {
      var _this$props = _this.props,
          onDrop = _this$props.onDrop,
          onDropAccepted = _this$props.onDropAccepted,
          onDropRejected = _this$props.onDropRejected,
          enablePreview = _this$props.enablePreview;

      var fileList = _this.getDataTransferItems(e, enablePreview);

      var _this$parseFiles = _this.parseFiles(fileList),
          _this$parseFiles2 = _slicedToArray(_this$parseFiles, 2),
          acceptedFiles = _this$parseFiles2[0],
          rejectedFiles = _this$parseFiles2[1];

      e.preventDefault();
      _this.enterCounter = 0;

      onDrop(acceptedFiles, rejectedFiles, e);

      if (rejectedFiles.length > 0) {
        onDropRejected(rejectedFiles, e);
      }

      if (acceptedFiles.length > 0) {
        onDropAccepted(acceptedFiles, e);
      }

      _this.setState({
        isDragAccepted: false,
        isDragRejected: false
      });
    };

    _this.fileAccepted = function (file) {
      return accepts(file, _this.props.accept);
    };

    _this.handleRef = function (el) {
      _this.fileInputEl = el;
    };

    _this.handleFocus = function () {
      return _this.setState({ focused: true });
    };

    _this.handleBlur = function () {
      return _this.setState({ focused: false });
    };

    _this.handleOnClick = function (e) {
      if (_this.fileInputEl.value && _this.props.allowRepeatFileSelection) {
        _this.fileInputEl.value = null;
      }
      _this.props.onClick(e);
    };

    _this.handleKeyDown = function (event) {
      if (_this.state.focused && keyEventIsClickButton(event)) {
        if (_this.props.allowRepeatFileSelection) {
          _this.fileInputEl.value = null;
        }
        // This bit of logic is necessary for MS browsers but causes unwanted warnings in Firefox
        // So we need to apply this logic only on MS browsers
        /* istanbul ignore if  */
        if (IS_MS) {
          event.stopPropagation();
          event.preventDefault();
          _this.fileInputEl.click();
        }
      }
    };

    _this.defaultId = generateElementId('FileDrop');
    _this.messagesId = generateElementId('FileDrop-messages');
    return _this;
  }

  _createClass(FileDrop, [{
    key: 'getDataTransferItems',
    value: function getDataTransferItems(event, enablePreview) {
      var list = Array.prototype.slice.call(getEventFiles(event, this.fileInputEl));

      if (list.length > 1) {
        list = this.props.allowMultiple ? list : [list[0]];
      }

      if (enablePreview) {
        return list.map(function (file) {
          return Object.assign({}, file, { preview: window.URL.createObjectURL(file) });
        });
      }

      return list;
    }
  }, {
    key: 'parseFiles',
    value: function parseFiles(fileList) {
      var _this2 = this;

      var acceptedFiles = [];
      var rejectedFiles = [];

      fileList.forEach(function (file) {
        if (_this2.fileAccepted(file) && _this2.fileMatchSize(file)) {
          acceptedFiles.push(file);
        } else {
          rejectedFiles.push(file);
        }
      });

      return [acceptedFiles, rejectedFiles];
    }
  }, {
    key: 'fileMatchSize',
    value: function fileMatchSize(file) {
      return file.size <= this.props.maxSize && file.size >= this.props.minSize;
    }
  }, {
    key: 'allFilesAccepted',
    value: function allFilesAccepted(files) {
      return files.every(this.fileAccepted);
    }
  }, {
    key: 'acceptStr',
    value: function acceptStr() {
      var accept = this.props.accept;

      return accept ? getAcceptList(accept).join(',') : null;
    }
  }, {
    key: 'renderLabel',
    value: function renderLabel() {
      var Label = this.props.label;
      if (typeof Label !== 'function') {
        return Label;
      }

      return React.createElement(Label, {
        isDragAccepted: this.state.isDragAccepted,
        isDragRejected: this.state.isDragRejected,
        disabled: this.props.disabled,
        readOnly: this.props.readOnly
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _classes;

      var _props = this.props,
          allowMultiple = _props.allowMultiple,
          disabled = _props.disabled,
          readOnly = _props.readOnly;

      var id = this.props.id || this.defaultId;
      var classes = (_classes = {}, _defineProperty(_classes, styles.label, true), _defineProperty(_classes, styles.dragRejected, this.state.isDragRejected || this.invalid), _defineProperty(_classes, styles.dragAccepted, this.state.isDragAccepted), _defineProperty(_classes, styles.focused, this.state.focused), _classes);
      var props = omitProps(this.props, FileDrop.propTypes);

      return React.createElement(
        'div',
        { className: styles.root },
        React.createElement(
          'label',
          {
            className: classnames(classes),
            htmlFor: id,
            onDragEnter: this.handleDragEnter,
            onDragOver: this.handleDragOver,
            onDragLeave: this.handleDragLeave,
            onDrop: this.handleDrop
          },
          React.createElement(
            'span',
            { className: styles.labelContent },
            React.createElement(
              'span',
              { className: styles.layout },
              this.renderLabel()
            )
          )
        ),
        React.createElement('input', Object.assign({}, props, {
          onClick: this.handleOnClick,
          type: 'file',
          className: styles.input,
          id: id,
          ref: this.handleRef,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur,
          onKeyDown: this.handleKeyDown,
          multiple: allowMultiple,
          accept: this.acceptStr(),
          onChange: this.handleDrop,
          'aria-describedby': this.hasMessages ? this.messagesId : null,
          disabled: disabled || readOnly,
          'aria-disabled': disabled || readOnly ? 'true' : null
        })),
        this.hasMessages ? React.createElement(
          View,
          { display: 'block', margin: 'small 0 0' },
          React.createElement(FormFieldMessages, { id: this.messagesId, messages: this.props.messages })
        ) : null
      );
    }
  }, {
    key: 'hasMessages',
    get: function get() {
      return this.props.messages && this.props.messages.length > 0;
    }
  }, {
    key: 'invalid',
    get: function get() {
      return this.hasMessages && this.props.messages.findIndex(function (message) {
        return message.type === 'error';
      }) >= 0;
    }
  }]);

  FileDrop.displayName = 'FileDrop'
  ;
  return FileDrop;
}(Component), _class2.propTypes = {
  /**
  * the id of the input (to link it to its label for a11y)
  */
  id: PropTypes.string,
  /**
  * the content of FileDrop, can be a component or an react node.
  * If given a component, it will receive isDragAccepted and isDragRejected as props
  */
  label: PropTypes.oneOfType([PropTypes.func, PropTypes.node]).isRequired,
  /**
  * the mime media type/s or file extension/s allowed to be dropped inside
  */
  accept: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
  /**
  * object with shape: `{
  * text: PropTypes.string,
  * type: PropTypes.oneOf(['error', 'hint', 'success', 'screenreader-only'])
  *   }`
  */
  messages: PropTypes.arrayOf(FormPropTypes.message),
  /**
  * callback called when clicking on drop area to select files to upload
  */
  onClick: PropTypes.func,
  /**
  * callback called when dropping files or when the file dialog window exits successfully
  */
  onDrop: PropTypes.func,
  /**
  * callback called when dropping allowed files
  */
  onDropAccepted: PropTypes.func,
  /**
  * callback called when dropping rejected files
  */
  onDropRejected: PropTypes.func,
  /**
  * callback called when dragging files
  * and passing through FileDrop's content for the first time
  */
  onDragEnter: PropTypes.func,
  /**
  * callback called when dragging files and passing through FileDrop's content
  */
  onDragOver: PropTypes.func,
  /**
  * callback called when dragging files and leaving FileDrop's content
  */
  onDragLeave: PropTypes.func,
  /**
  * flag to use window.URL.createObjectURL for each dropped file and passing it through file.preview
  */
  enablePreview: PropTypes.bool,
  /**
  * flag to allow selection multiple files to drop at once
  */
  allowMultiple: PropTypes.bool,
  /**
  * the maximum file size allowed
  */
  maxSize: PropTypes.number,
  /**
  * the minimum file size allowed
  */
  minSize: PropTypes.number,
  /**
   * Whether or not to allow the file browser to upload the same file more than once.
   */
  allowRepeatFileSelection: PropTypes.bool,
  /**
   * Whether or not to disable the input
   */
  disabled: PropTypes.bool,
  /**
   * Works just like disabled but keeps the same styles as if it were active
   */
  readOnly: PropTypes.bool
}, _class2.defaultProps = {
  onClick: function onClick(e) {},
  onDrop: function onDrop(acceptedFiles, rejectedFiles, e) {},
  onDropAccepted: function onDropAccepted(acceptedFiles, e) {},
  onDropRejected: function onDropRejected(rejectedFiles, e) {},
  onDragEnter: function onDragEnter(e) {},
  onDragOver: function onDragOver(e) {},
  onDragLeave: function onDragLeave(e) {},

  enablePreview: false,
  allowMultiple: false,
  allowRepeatFileSelection: true,
  maxSize: Infinity,
  minSize: 0,
  readOnly: false,
  messages: []
}, _temp)) || _class);
export { FileDrop as default };