var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp, _initialiseProps;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import React, { Component } from 'react';
import PropTypes from 'prop-types';

import CustomPropTypes from '@instructure/ui-utils/lib/react/CustomPropTypes';
import I18nPropTypes from '@instructure/ui-i18n/lib/utils/I18nPropTypes';
import FormPropTypes from '../../utils/FormPropTypes';
import warning from '@instructure/ui-utils/lib/warning';
import DateTime from '@instructure/ui-i18n/lib/DateTime';
import Locale from '@instructure/ui-i18n/lib/Locale';

import DateInput from '../DateInput/index';
import TimeInput from '../TimeInput/index';
import FormFieldGroup from '../FormFieldGroup/index';

/**
---
category: components/forms
---
**/
var DateTimeInput = (_temp = _class = function (_Component) {
  _inherits(DateTimeInput, _Component);

  function DateTimeInput(props, context) {
    _classCallCheck(this, DateTimeInput);

    var _this = _possibleConstructorReturn(this, (DateTimeInput.__proto__ || Object.getPrototypeOf(DateTimeInput)).call(this, props, context));

    _initialiseProps.call(_this);

    var date = void 0,
        time = void 0,
        result = void 0;
    var messages = [];
    var initialValue = props.value || props.defaultValue || undefined; // eslint-disable-line no-undefined
    var locale = props.locale || context.locale || Locale.browserLocale();
    var timezone = props.timezone || context.timezone || DateTime.browserTimeZone();
    if (initialValue) {
      // guarantee the initialValue is in the given timezone
      initialValue = DateTime.toLocaleString(initialValue, locale, timezone); // eslint-disable-line semi

      // eslint-disable-line semi
      var _this$splitDateAndTim = _this.splitDateAndTime(initialValue);

      date = _this$splitDateAndTim.date;
      time = _this$splitDateAndTim.time;

      var _this$combineDateAndT = _this.combineDateAndTime(date, time);

      result = _this$combineDateAndT.result;
      messages = _this$combineDateAndT.messages;
    }
    messages = _this.mergeMessages(messages, _this.props);

    _this.state = {
      date: date, time: time, result: result, messages: messages
    };

    _this._dateInput = null;
    _this._timeInput = null;
    return _this;
  }

  _createClass(DateTimeInput, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      warning(nextProps.locale === this.locale || nextProps.timezone === this.timezone, 'You cannot change the locale or timezone of a DateTimeInput. The new value(s) will be ignored.');

      if (nextProps.value) {
        // guarantee the new datetime remains in the given timezone
        var newValue = DateTime.toLocaleString(nextProps.value, this.locale, this.timezone);

        var _splitDateAndTime = this.splitDateAndTime(newValue),
            date = _splitDateAndTime.date,
            time = _splitDateAndTime.time;

        var _combineDateAndTime = this.combineDateAndTime(date, time),
            result = _combineDateAndTime.result,
            messages = _combineDateAndTime.messages;

        messages = this.mergeMessages(messages, nextProps);
        this.setState({ date: date, time: time, result: result, messages: messages });
      } else {
        this.setState({ messages: this.mergeMessages(this.state.messages, nextProps) });
      }
    }
  }, {
    key: 'mergeMessages',
    value: function mergeMessages(messages, props) {
      return props.messages ? messages.concat(props.messages) : messages;
    }
    /**
    * Focus me.
    *
    * When this `DateTimeInput` gets focus, we hand it off to the
    * underlying `DateInput`.
    */

  }, {
    key: 'focus',
    value: function focus() {
      if (this._dateInput) {
        this._dateInput.focus();
      }
    }
  }, {
    key: 'parseDate',
    value: function parseDate(datetime) {
      return DateTime.parse(datetime, this.locale, this.timezone);
    }
  }, {
    key: 'errorMessage',
    value: function errorMessage(rawDateValue, rawTimeValue) {
      var invalidDateTimeMessage = this.props.invalidDateTimeMessage;

      if (typeof invalidDateTimeMessage === 'function') {
        invalidDateTimeMessage = invalidDateTimeMessage(rawDateValue, rawTimeValue);
      }
      // eslint-disable-next-line no-undefined
      return invalidDateTimeMessage ? { text: invalidDateTimeMessage, type: 'error' } : undefined;
    }
  }, {
    key: 'validMessage',
    value: function validMessage(datetime) {
      var parsedDate = this.parseDate(datetime);

      var message = '';
      if (!parsedDate.isValid()) {
        var _datetime$split = datetime.split('T'),
            _datetime$split2 = _slicedToArray(_datetime$split, 2),
            d = _datetime$split2[0],
            t = _datetime$split2[1];

        message = this.errorMessage(d, t);
      } else {
        message = {
          text: parsedDate.format(this.props.messageFormat),
          type: 'success'
        };
      }
      return message;
    }
  }, {
    key: 'splitDateAndTime',
    value: function splitDateAndTime(datetime) {
      if (datetime) {
        var dtarr = datetime.split('T');
        return {
          date: dtarr[0] || undefined, // eslint-disable-line no-undefined
          time: dtarr[1] || undefined // eslint-disable-line no-undefined
        };
      }
      return { date: undefined, time: undefined // eslint-disable-line no-undefined
      };
    }
  }, {
    key: 'combineDateAndTime',
    value: function combineDateAndTime(date, time) {
      var retval = {
        result: undefined, // eslint-disable-line no-undefined
        messages: []
      };
      if (date && time) {
        var datetime = date + 'T' + time;
        retval = {
          result: datetime,
          messages: [this.validMessage(datetime)]
        };
      } else if (date) {
        // time will come from the date
        retval = {
          result: date,
          messages: [this.validMessage(date)]
        };
      } else if (this.props.required) {
        retval = {
          result: undefined, // eslint-disable-line no-undefined
          messages: [this.errorMessage(date, time)]
        };
      }
      // note: no date + a valid time is handled in onTimeChange
      return retval;
    }
  }, {
    key: 'fireChange',
    value: function fireChange(event) {
      if (this.props.onChange) {
        this.props.onChange(event, this.state.result);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          description = _props.description,
          datePlaceholder = _props.datePlaceholder,
          dateLabel = _props.dateLabel,
          dateNextLabel = _props.dateNextLabel,
          datePreviousLabel = _props.datePreviousLabel,
          dateFormat = _props.dateFormat,
          dateInputRef = _props.dateInputRef,
          timeLabel = _props.timeLabel,
          timeFormat = _props.timeFormat,
          timeStep = _props.timeStep,
          timeInputRef = _props.timeInputRef,
          layout = _props.layout,
          required = _props.required,
          disabled = _props.disabled,
          readOnly = _props.readOnly;

      var locale = this.locale;
      var timezone = this.timezone;

      return React.createElement(
        FormFieldGroup,
        {
          description: description,
          colSpacing: 'medium',
          rowSpacing: 'small',
          layout: layout,
          vAlign: 'top',
          messages: this.state.messages
        },
        React.createElement(DateInput, {
          dateValue: this.state.result,
          inputRef: dateInputRef,
          ref: this.dateInputComponentRef,
          placeholder: datePlaceholder,
          label: dateLabel,
          locale: locale,
          format: dateFormat,
          nextLabel: dateNextLabel,
          onDateChange: this.onDateChange,
          onBlur: this.onInputBlur,
          previousLabel: datePreviousLabel,
          timezone: timezone,
          validationFeedback: false,
          required: required,
          disabled: disabled,
          readOnly: readOnly
        }),
        React.createElement(TimeInput, {
          ref: this.timeInputComponentRef,
          label: timeLabel,
          locale: locale,
          format: timeFormat,
          onChange: this.onTimeChange,
          onBlur: this.onInputBlur,
          step: timeStep,
          timezone: timezone,
          value: this.state.result,
          inputRef: timeInputRef,
          disabled: disabled,
          readOnly: readOnly
        })
      );
    }
  }, {
    key: 'focused',
    get: function get() {
      return this._dateInput && this._dateInput.focused || this._timeInput && this._timeInput.focused;
    }
  }, {
    key: 'locale',
    get: function get() {
      return this.props.locale || this.context.locale || Locale.browserLocale();
    }
  }, {
    key: 'timezone',
    get: function get() {
      return this.props.timezone || this.context.timezone || DateTime.browserTimeZone();
    }
  }]);

  DateTimeInput.displayName = 'DateTimeInput'
  ;
  return DateTimeInput;
}(Component), _class.propTypes = {
  /**
  * The label over the composite `DateTimeInput` component
  **/
  description: PropTypes.node.isRequired,
  /**
  * The label over the Date Input
  **/
  dateLabel: PropTypes.string.isRequired,
  /**
  * The label to put on the previous month button of the calendar.
  **/
  datePreviousLabel: PropTypes.string.isRequired,
  /**
  * The label to put on the next month button of the calendar.
  **/
  dateNextLabel: PropTypes.string.isRequired,
  /**
  * HTML placeholder text to display when the date input has no value.
  * This should be hint text, not a label replacement.
  **/
  datePlaceholder: PropTypes.string,
  /**
  * The format of the date shown in the `DateInput` when a date is selected.
  * Valid formats are compatible with
  * [moment.js formats](https://momentjs.com/docs/#/displaying/format/),
  * including localized formats.
  *
  * If omitted, deferrs to the underlying `DateInput`'s default.
  **/
  dateFormat: PropTypes.string,
  /**
  * The label over the time input
  **/
  timeLabel: PropTypes.string.isRequired,
  /**
   * The number of minutes to increment by when generating the allowable time options.
   */
  timeStep: PropTypes.oneOf([5, 10, 15, 20, 30, 60]),
  /**
  * The format of the time shown in the `TimeInput` when a time is selected.
  * Valid formats are compatible with
  * [moment.js formats](https://momentjs.com/docs/#/displaying/format/),
  * including localized formats.
  *
  * If omitted, deferrs to the underlying `TimeInput`'s default.
  **/
  timeFormat: PropTypes.string,
  /**
  * A standard language identifier.
  *
  * See [moment.js i18n](https://momentjs.com/docs/#/i18n/) for more details.
  *
  * This property can also be set via a context property and if both are set then the component property takes
  * precedence over the context property.
  *
  * The web browser's locale will be used if no value is set via a component property or a context
  * property.
  **/
  locale: PropTypes.string,
  /**
  * A timezone identifier in the format: Area/Location
  *
  * See [List of tz database time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the list
  * of possible options.
  *
  * This property can also be set via a context property and if both are set then the component property takes
  * precedence over the context property.
  *
  * The web browser's timezone will be used if no value is set via a component property or a context
  * property.
  **/
  timezone: PropTypes.string,
  /**
  * The message shown to the user when the data is invalid.
  * If a string, shown to the user anytime the input is invalid.
  *
  * If a function, receives 2 parameters:
  *  *rawDateValue*: the string entered as a date by the user,
  *  *rawTimeValue*: the string entered as a time by the user.
  *
  * Currently, times must be selected from a list, it can never be incorrect,
  * Though `invalidDateTimeMessage` will be called if the user selects a time without
  * setting the date.
  *
  * Either parameter is undefined if the user has not entered anything,
  * which you can use to test for no input if the `DateTimeInput` is required.
  **/
  invalidDateTimeMessage: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,
  /**
  * Messages my parent would like displayed
  * object with shape: `{
  *   text: PropTypes.string,
  *   type: PropTypes.oneOf(['error', 'hint', 'success', 'screenreader-only'])
  *  }
  */
  messages: PropTypes.arrayOf(FormPropTypes.message),
  /**
  * This format of the composite date-time when displayed in messages.
  * Valid formats are compatible with
  * [moment.js formats](https://momentjs.com/docs/#/displaying/format/),
  * including localized formats.
  **/
  messageFormat: PropTypes.string,
  /**
  * Vertically stacked, horizontally arranged in 2 columns, or inline.
  * See [FormFieldGroup](#FormFieldGroup) for details.
  **/
  layout: PropTypes.oneOf(['stacked', 'columns', 'inline']),
  /**
  * An ISO 8601 formatted date string representing the current date-time
  * (must be accompanied by an onChange prop).
  **/
  value: CustomPropTypes.controllable(I18nPropTypes.iso8601, 'onChange'),
  /**
  * An ISO 8601 formatted date string to use if `value` isn't provided.
  **/
  defaultValue: I18nPropTypes.iso8601,
  required: PropTypes.bool,
  /**
   * Whether or not to disable the inputs
   */
  disabled: PropTypes.bool,
  /**
   * Works just like disabled but keeps the same styles as if it were active
   */
  readOnly: PropTypes.bool,
  /**
  * Called when the date-time value has changed.
  * The passed in parameters are
  * *event*: the triggering event (which may be from the underlying
  * `DateInput` or `TimeInput`), *isoValue*: the new date value in ISO 8601 format.
  **/
  onChange: PropTypes.func,
  /**
  * The <input> element where the date is entered.
  **/
  dateInputRef: PropTypes.func,
  /**
  * The <input> element where the time is entered.
  **/
  timeInputRef: PropTypes.func
}, _class.defaultProps = {
  layout: 'inline',
  timeStep: 30,
  timezone: '',
  messageFormat: 'LLL',
  required: false,
  disabled: false,
  readOnly: false
}, _class.contextTypes = {
  locale: PropTypes.string,
  timezone: PropTypes.string
}, _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.onDateChange = function (event, newISODate, rawValue, isInvalid) {
    var newD = void 0;
    var newT = _this2.state.time;
    var result = void 0;
    var messages = [];
    if (newISODate) {
      newD = newISODate.replace(/T.*/, '');
      if (!newT) {
        newT = '23:59'; // until a time is given, this is consistent with existing components in canvas.
      }
    }
    if (isInvalid) {
      messages.push(_this2.errorMessage(rawValue, undefined)); // eslint-disable-line no-undefined
    } else {
      var _combineDateAndTime2 = _this2.combineDateAndTime(newD, newT);

      result = _combineDateAndTime2.result;
      messages = _combineDateAndTime2.messages;
    }
    messages = _this2.mergeMessages(messages, _this2.props);
    // only fire onChange if the value has actually changed
    var fireChange = result !== _this2.state.result ? _this2.fireChange.bind(_this2, event) : null;
    _this2.setState({ date: newD, time: newT, result: result, messages: messages }, fireChange);
  };

  this.onTimeChange = function (event, timeVal) {
    var newT = void 0;
    var messages = [];
    var result = void 0;
    if (timeVal && timeVal.value) {
      // put in local time, or it may get the date wrong
      newT = DateTime.parse(timeVal.value, _this2.locale, _this2.timezone);
      newT = newT.format().replace(/.*T/, '');
    }
    if (!_this2.state.date) {
      messages.push(_this2.errorMessage(undefined, timeVal.label)); // eslint-disable-line no-undefined
    } else {
      var _combineDateAndTime3 = _this2.combineDateAndTime(_this2.state.date, newT);

      result = _combineDateAndTime3.result;
      messages = _combineDateAndTime3.messages;
    }
    messages = _this2.mergeMessages(messages, _this2.props);
    // only fire onChange if the value has actually changed
    var fireChange = result !== _this2.state.result ? _this2.fireChange.bind(_this2, event) : null;
    _this2.setState({ time: newT, result: result, messages: messages }, fireChange);
  };

  this.onInputBlur = function (event) {
    if (_this2.props.required && !_this2.state.result) {
      var messages = [_this2.errorMessage(undefined, _this2.state.time)]; // eslint-disable-line no-undefined
      _this2.setState({ messages: messages });
    }
  };

  this.dateInputComponentRef = function (node) {
    _this2._dateInput = node;
  };

  this.timeInputComponentRef = function (node) {
    _this2._timeInput = node;
  };
}, _temp);


export default DateTimeInput;