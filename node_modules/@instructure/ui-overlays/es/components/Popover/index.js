var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp, _class2, _temp2, _dec, _dec2, _dec3, _class3, _class4, _temp3;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import React, { Component } from 'react';
import PropTypes from 'prop-types';

import ContextView from '@instructure/ui-layout/lib/components/ContextView';
import View from '@instructure/ui-layout/lib/components/View';

import Dialog from '@instructure/ui-a11y/lib/components/Dialog';
import bidirectional from '@instructure/ui-i18n/lib/bidirectional';
import CloseButton from '@instructure/ui-buttons/lib/components/CloseButton';
import Position, { PositionTarget, PositionContent } from '@instructure/ui-layout/lib/components/Position';

import CustomPropTypes from '@instructure/ui-utils/lib/react/CustomPropTypes';
import LayoutPropTypes from '@instructure/ui-layout/lib/utils/LayoutPropTypes';
import ComponentIdentifier, { pick } from '@instructure/ui-utils/lib/react/ComponentIdentifier';
import containsActiveElement from '@instructure/ui-utils/lib/dom/containsActiveElement';
import createChainedFunction from '@instructure/ui-utils/lib/createChainedFunction';
import requestAnimationFrame from '@instructure/ui-utils/lib/dom/requestAnimationFrame';
import safeCloneElement from '@instructure/ui-utils/lib/react/safeCloneElement';
import shallowEqual from '@instructure/ui-utils/lib/shallowEqual';
import px from '@instructure/ui-utils/lib/px';
import handleMouseOverOut from '@instructure/ui-utils/lib/dom/handleMouseOverOut';
import { pickProps } from '@instructure/ui-utils/lib/react/passthroughProps';
import deprecated from '@instructure/ui-utils/lib/react/deprecated';
import warning from '@instructure/ui-utils/lib/warning';
import { parsePlacement } from '@instructure/ui-layout/lib/utils/calculateElementPosition';
import { mirrorHorizontalPlacement } from '@instructure/ui-layout/lib/utils/mirrorPlacement';
import ThemeablePropTypes from '@instructure/ui-themeable/lib/utils/ThemeablePropTypes';

var PopoverTrigger = (_temp = _class = function (_ComponentIdentifier) {
  _inherits(PopoverTrigger, _ComponentIdentifier);

  function PopoverTrigger() {
    _classCallCheck(this, PopoverTrigger);

    return _possibleConstructorReturn(this, (PopoverTrigger.__proto__ || Object.getPrototypeOf(PopoverTrigger)).apply(this, arguments));
  }

  return PopoverTrigger;
}(ComponentIdentifier), _class.displayName = 'PopoverTrigger', _temp);
var PopoverContent = (_temp2 = _class2 = function (_ComponentIdentifier2) {
  _inherits(PopoverContent, _ComponentIdentifier2);

  function PopoverContent() {
    _classCallCheck(this, PopoverContent);

    return _possibleConstructorReturn(this, (PopoverContent.__proto__ || Object.getPrototypeOf(PopoverContent)).apply(this, arguments));
  }

  return PopoverContent;
}(ComponentIdentifier), _class2.displayName = 'PopoverContent', _temp2);

/**
---
category: components/dialogs
---
**/

var Popover = (_dec = deprecated('3.0.0', {
  renderOffscreen: 'shouldRenderOffscreen',
  rootClose: 'shouldCloseOnDocumentClick'
}), _dec2 = deprecated('5.0.0', {
  closeButtonLabel: true,
  closeButtonRef: true,
  applicationElement: true
}), _dec3 = bidirectional(), _dec(_class3 = _dec2(_class3 = _dec3(_class3 = (_temp3 = _class4 = function (_Component) {
  _inherits(Popover, _Component);

  function Popover(props) {
    _classCallCheck(this, Popover);

    var _this3 = _possibleConstructorReturn(this, (Popover.__proto__ || Object.getPrototypeOf(Popover)).call(this, props));

    _this3.show = function () {
      if (typeof _this3.props.show === 'undefined') {
        _this3.setState({ show: true });
      }

      if (typeof _this3.props.onToggle === 'function') {
        _this3.props.onToggle(true);
      }
    };

    _this3.hide = function (e, documentClick) {
      var _this3$props = _this3.props,
          onDismiss = _this3$props.onDismiss,
          onToggle = _this3$props.onToggle;


      if (typeof _this3.props.show === 'undefined') {
        _this3.setState(function (_ref) {
          var show = _ref.show;

          if (show) {
            onDismiss(e, documentClick);
          }
          return { show: false };
        });
      } else {
        if (_this3.props.show) {
          onDismiss(e, documentClick);
        }
      }

      onToggle(false);
    };

    _this3.toggle = function () {
      if (_this3.shown) {
        _this3.hide();
      } else {
        _this3.show();
      }
    };

    _this3.handleDialogBlur = function (event) {
      _this3.hide(event);
    };

    _this3.handlePositionChanged = function (_ref2) {
      var placement = _ref2.placement;

      _this3.setState(Object.assign({
        closeButtonPlacement: _this3.getCloseButtonPlacement(_this3.props),
        placement: placement
      }, _this3.computeOffsets(placement)));
    };

    _this3.state = {
      placement: props.placement,
      offsetX: props.offsetX,
      offsetY: props.offsetY
    };

    if (typeof props.show === 'undefined') {
      _this3.state.show = props.defaultShow;
    }

    _this3._raf = [];
    return _this3;
  }

  _createClass(Popover, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var _this4 = this;

      this._handleMouseOver = handleMouseOverOut.bind(null, function () {
        _this4.show();
      });
      this._handleMouseOut = handleMouseOverOut.bind(null, function () {
        _this4.hide();
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._raf.forEach(function (request) {
        return request.cancel();
      });
      this._raf = [];
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      return !(shallowEqual(this.props, nextProps) && shallowEqual(this.state, nextState));
    }
  }, {
    key: 'getCloseButtonPlacement',
    value: function getCloseButtonPlacement(props) {
      var placement = props.placement.split(' ');

      if (placement.indexOf('end') >= 0) {
        return 'start';
      } else {
        return 'end';
      }
    }
  }, {
    key: 'renderTrigger',
    value: function renderTrigger() {
      var _this5 = this;

      var trigger = pick(Popover.Trigger, this.props.children);

      if (trigger) {
        var _props = this.props,
            on = _props.on,
            shouldContainFocus = _props.shouldContainFocus;

        var onClick = void 0;
        var onBlur = void 0;
        var onFocus = void 0;
        var onMouseOut = void 0;
        var onMouseOver = void 0;
        var expanded = void 0;

        if (on.indexOf('click') > -1) {
          onClick = function onClick() {
            _this5.toggle();
          };
        }

        if (on.indexOf('hover') > -1) {
          warning(!(on === 'hover'), '[Popover] Specifying only the `"hover"` trigger limits the visibilty of the overlay to just mouse users. ' + 'Consider also including the `"focus"` trigger ' + 'so that touch and keyboard only users can see the overlay as well.');

          onMouseOver = this._handleMouseOver;
          onMouseOut = this._handleMouseOut;
        }

        if (on.indexOf('focus') > -1) {
          onFocus = function onFocus() {
            _this5.show();
          };
          onBlur = function onBlur(event) {
            _this5._raf.push(requestAnimationFrame(function () {
              if (!containsActiveElement(_this5._view)) {
                _this5.hide();
              }
            }));
          };
        }

        if (shouldContainFocus) {
          // only set aria-expanded if popover can contain focus
          expanded = this.shown ? 'true' : 'false';
        } else {
          expanded = null;
        }

        trigger = safeCloneElement(trigger, {
          ref: function ref(el) {
            _this5._trigger = el;
          },
          'aria-expanded': expanded,
          onClick: createChainedFunction(onClick, this.props.onClick),
          onBlur: createChainedFunction(onBlur, this.props.onBlur),
          onFocus: createChainedFunction(onFocus, this.props.onFocus),
          onMouseOut: createChainedFunction(onMouseOut, this.props.onMouseOut),
          onMouseOver: createChainedFunction(onMouseOver, this.props.onMouseOver)
        });
      }

      return trigger;
    }
  }, {
    key: 'renderCloseButton',
    value: function renderCloseButton() {
      var _this6 = this;

      return this.props.closeButtonLabel ? React.createElement(
        CloseButton,
        {
          placement: this.state.closeButtonPlacement,
          offset: 'x-small',
          variant: this.props.variant === 'inverse' ? 'icon-inverse' : 'icon',
          buttonRef: function buttonRef(el) {
            _this6._closeButton = el;
            if (typeof _this6.props.closeButtonRef === 'function') {
              _this6.props.closeButtonRef(el);
            }
          },
          onClick: this.hide
        },
        this.props.closeButtonLabel
      ) : null;
    }
  }, {
    key: 'renderContent',
    value: function renderContent() {
      var _this7 = this;

      var content = pick(Popover.Content, this.props.children);

      if (this.shown) {
        content = React.createElement(
          Dialog,
          Object.assign({}, pickProps(this.props, Dialog.propTypes), {
            display: 'block',
            open: this.shown,
            onBlur: this.handleDialogBlur,
            onDismiss: this.hide,
            defaultFocusElement: this.defaultFocusElement
          }),
          content
        );
      }

      if (this.shown || this.props.shouldRenderOffscreen) {
        var ViewElement = void 0;
        var viewProps = {
          ref: function ref(c) {
            return _this7._view = c;
          },
          elementRef: this.props.contentRef,
          background: this.props.variant,
          stacking: this.props.stacking,
          display: 'block'
        };

        var placement = this.state.placement;


        if (this.props.withArrow) {
          ViewElement = ContextView;
          viewProps = Object.assign({}, viewProps, {
            placement: this.rtl ? mirrorHorizontalPlacement(placement, ' ') : placement
          });
        } else {
          ViewElement = View;
          viewProps = Object.assign({}, viewProps, {
            borderWidth: 'small',
            borderRadius: 'medium'
          });
        }

        return React.createElement(
          ViewElement,
          viewProps,
          this.renderCloseButton(),
          content
        );
      } else {
        return null;
      }
    }
  }, {
    key: 'computeOffsets',
    value: function computeOffsets(placement) {
      var _props2 = this.props,
          offsetX = _props2.offsetX,
          offsetY = _props2.offsetY;


      if (this.props.alignArrow && this._view) {
        var secondaryPlacement = parsePlacement(placement)[1];
        var _view$theme = this._view.theme,
            arrowSize = _view$theme.arrowSize,
            arrowBorderWidth = _view$theme.arrowBorderWidth;

        var offsetAmount = (px(arrowSize) + px(arrowBorderWidth)) * 2;
        if (secondaryPlacement === 'start') {
          offsetX = offsetAmount;
        } else if (secondaryPlacement === 'end') {
          offsetX = -offsetAmount;
        } else if (secondaryPlacement === 'top') {
          offsetY = offsetAmount;
        } else if (secondaryPlacement === 'bottom') {
          offsetY = -offsetAmount;
        }
      }

      return {
        offsetX: offsetX,
        offsetY: offsetY
      };
    }
  }, {
    key: 'render',
    value: function render() {
      var positionProps = this.positionProps;

      if (this.props.positionTarget) {
        return React.createElement(
          'span',
          null,
          this.renderTrigger(),
          React.createElement(
            Position,
            positionProps,
            React.createElement(
              PositionContent,
              null,
              this.renderContent()
            )
          )
        );
      } else {
        return React.createElement(
          Position,
          positionProps,
          React.createElement(
            PositionTarget,
            null,
            this.renderTrigger()
          ),
          React.createElement(
            PositionContent,
            null,
            this.renderContent()
          )
        );
      }
    }
  }, {
    key: 'placement',
    get: function get() {
      var placement = this.props.placement;


      if (this.rtl) {
        placement = mirrorHorizontalPlacement(placement, ' ');
      }

      return !this.shown && this.props.shouldRenderOffscreen ? 'offscreen' : placement;
    }
  }, {
    key: 'shown',
    get: function get() {
      return typeof this.props.show === 'undefined' ? this.state.show : this.props.show;
    }
  }, {
    key: 'defaultFocusElement',
    get: function get() {
      return this.props.defaultFocusElement;
    }
  }, {
    key: 'positionProps',
    get: function get() {
      return Object.assign({}, pickProps(this.props, Position.propTypes), {
        offsetX: this.state.offsetX,
        offsetY: this.state.offsetY,
        trackPosition: this.shown,
        placement: this.placement,
        onPositioned: createChainedFunction(this.handlePositionChanged, this.props.onShow),
        onPositionChanged: this.handlePositionChanged,
        target: this.props.positionTarget
      });
    }
  }]);

  Popover.displayName = 'Popover'
  ;
  return Popover;
}(Component), _class4.Trigger = PopoverTrigger, _class4.Content = PopoverContent, _class4.propTypes = {
  /**
   * Children of the `<Popover />`
   */
  children: CustomPropTypes.Children.oneOf([PopoverTrigger, PopoverContent]),

  /**
   * The placement of the content in relation to the trigger
   */
  placement: LayoutPropTypes.placement,

  /**
   * The action that causes the Content to display (`click`, `hover`, `focus`)
   */
  on: PropTypes.oneOfType([PropTypes.oneOf(['click', 'hover', 'focus']), PropTypes.arrayOf(PropTypes.oneOf(['click', 'hover', 'focus']))]),

  variant: PropTypes.oneOf(['default', 'inverse']),

  /**
  * Controls the z-index depth for the `<Popover />` content
  */
  stacking: ThemeablePropTypes.stacking,

  /**
   * Whether or not the content should be rendered on initial render.
   */
  defaultShow: PropTypes.bool,

  /**
  * Whether or not the `<Popover />` is shown (should be accompanied by `onToggle`)
  */
  show: CustomPropTypes.controllable(PropTypes.bool, 'onToggle', 'defaultShow'),

  /**
   *
   * A function that returns a reference to the content element
   */
  contentRef: PropTypes.func,

  /**
   * Call this function when the content visibility is toggled. When used with `show`,
   * `<Popover />` will not control its own state.
   */
  onToggle: PropTypes.func,

  /**
   * Callback fired when component is clicked
   */
  onClick: PropTypes.func,

  /**
   * Callback fired when trigger is focused
   */
  onFocus: PropTypes.func,

  /**
   * Callback fired when component is blurred
   */
  onBlur: PropTypes.func,

  /**
   * Callback fired when content is rendered and positioned
   */
  onShow: PropTypes.func,

  /**
   * Callback fired when mouse is over trigger
   */
  onMouseOver: PropTypes.func,

  /**
   * Callback fired when mouse leaves trigger
   */
  onMouseOut: PropTypes.func,

  /**
   * Callback fired when the `<Popover />` requests to be hidden (via close button, escape key, etc.)
   */
  onDismiss: PropTypes.func,

  /**
  * Should the `<Popover />` display with an arrow pointing to the trigger
  */
  withArrow: PropTypes.bool,

  /**
   * An accessible label for the close button. The close button won't display without this label.
   */
  closeButtonLabel: PropTypes.string,

  /**
   * A function that returns a reference to the close button element
   */
  closeButtonRef: PropTypes.func,

  /**
   * An accessible label for the `<Popover />` content
   */
  label: PropTypes.string,

  /**
   * An element or a function returning an element to focus by default
   */
  defaultFocusElement: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),

  /**
  * Should the `<Popover />` render offscreen when visually hidden
  */
  shouldRenderOffscreen: PropTypes.bool,

  /**
   * Whether focus should contained within the `<Popover/>` when it is open
   */
  shouldContainFocus: PropTypes.bool,

  /**
   * Whether focus should be returned to the trigger when the `<Popover/>` is closed
   */
  shouldReturnFocus: PropTypes.bool,

  /**
   * Should the `<Popover />` hide when clicks occur outside the content
   */
  shouldCloseOnDocumentClick: PropTypes.bool,

  /**
   * Should the `<Popover />` hide when the escape key is pressed
   */
  shouldCloseOnEscape: PropTypes.bool,

  /**
   * The horizontal offset for the positioned content
   */
  offsetX: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * The vertical offset for the positioned content
   */
  offsetY: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * Callback fired when the position changes
   */
  onPositionChanged: PropTypes.func,

  /**
   * Callback fired when content has been mounted and is initially positioned
   */
  onPositioned: PropTypes.func,

  /**
   * Whether or not position should be tracked or just set on initial render
   */
  trackPosition: PropTypes.bool,

  /**
   * Should the `<Popover />` be positioned within some container.
   */
  constrain: Position.propTypes.constrain,

  /**
   * An element or a function returning an element to use as the mount node
   * for the `<Popover />` (defaults to `document.body`)
   */
  mountNode: PropTypes.oneOfType([CustomPropTypes.element, PropTypes.func]),

  /**
   * Insert the element at the 'top' of the mountNode or at the 'bottom'
   */
  insertAt: PropTypes.oneOf(['bottom', 'top']),

  /**
   * An element, function returning an element, or array of elements that will not be hidden from
   * the screen reader when the `<Popover />` is open
   */
  liveRegion: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.element), PropTypes.element, PropTypes.func]),

  /**
   * Target element for positioning the Popover (if it differs from the trigger)
   */
  positionTarget: PropTypes.oneOfType([CustomPropTypes.element, PropTypes.func]),

  /**
   * should the content offset to align by its arrow
   */
  alignArrow: PropTypes.bool
}, _class4.defaultProps = {
  children: null,
  onToggle: function onToggle(open) {},
  onClick: function onClick(event) {},
  onFocus: function onFocus(event) {},
  onBlur: function onBlur(event) {},
  onMouseOver: function onMouseOver(event) {},
  onMouseOut: function onMouseOut(event) {},
  onShow: function onShow(position) {},
  onDismiss: function onDismiss(event, documentClick) {},
  placement: 'bottom center',
  stacking: 'topmost',
  offsetX: 0,
  offsetY: 0,
  variant: 'default',
  on: ['hover', 'focus'],
  contentRef: function contentRef(el) {},
  defaultShow: false,
  withArrow: true,
  trackPosition: true,
  constrain: 'window',
  onPositioned: function onPositioned(position) {},
  onPositionChanged: function onPositionChanged(position) {},
  shouldRenderOffscreen: false,
  shouldContainFocus: false,
  shouldReturnFocus: true,
  shouldCloseOnDocumentClick: true,
  shouldCloseOnEscape: true,
  defaultFocusElement: null,
  label: null,
  mountNode: null,
  insertAt: 'bottom',
  liveRegion: null,
  positionTarget: null,
  alignArrow: false
}, _temp3)) || _class3) || _class3) || _class3);


export default Popover;
export { PopoverTrigger, PopoverContent };