var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import cloneArray from '@instructure/ui-utils/lib/cloneArray';
import warning from '@instructure/ui-utils/lib/warning';
import getComputedStyle from '@instructure/ui-utils/lib/dom/getComputedStyle';
import getBoundingClientRect from '@instructure/ui-utils/lib/dom/getBoundingClientRect';

import measureText from './measureText';
import cleanString from './cleanString';
import cleanData from './cleanData';

/**
 * ---
 * parent: TruncateText
 * ---
 * Truncate the text content of an HTML element and its children.
 *
 * @param {DOMNode} element A single element containing the content to be truncated.
 * @param {Object} options={} The options object.
 * @param {DOMNode} options.parent An optional parent element to use for calculations.
 * @param {number|string} options.maxLines Number of lines to allow before truncating.
 * @param {string} options.position=end Where to place the ellipsis within the string.
 * @param {string} options.truncate=character Add ellipsis after words or after any character.
 * @param {string} options.ellipsis=\u2026 Where to place the ellipsis within the string.
 * @param {string[]} options.ignore Characters to ignore at truncated end of string.
 * @param {number} options.lineHeight=1.2 Unitless multiplier to use in case element can have
 * 'normal' lineHeight. Adjust this to better match your font if needed.
 */

export function truncate(element, options) {
  var truncator = new Truncator(element, options);
  if (truncator) {
    return truncator.truncate();
  }
}

var Truncator = function () {
  function Truncator(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Truncator);

    this._options = {
      parent: options.parent || element.parentElement,
      maxLines: options.maxLines || 1,
      position: options.position || 'end',
      truncate: options.truncate || 'character',
      ellipsis: options.ellipsis || '\u2026',
      ignore: options.ignore || [' ', '.', ','],
      lineHeight: options.lineHeight || 1.2
    };

    if (!element) {
      warning(element, '[Truncator] No element to truncate.');
      return;
    }

    this._stage = element;

    if (options.parent) {
      this._parent = this._options.parent;
    } else {
      this._parent = this._options.maxLines === 'auto' ? this._stage.parentElement : this._stage;
    }

    this._truncatedText = this._parent.textContent;
    this._isTruncated = false;

    this.setup();
  }

  _createClass(Truncator, [{
    key: 'setup',
    value: function setup() {
      if (!this._stage) {
        return;
      }

      var _options = this._options,
          maxLines = _options.maxLines,
          truncate = _options.truncate,
          lineHeight = _options.lineHeight;

      var style = getComputedStyle(this._parent);
      // if no explicit lineHeight is inherited, use lineHeight multiplier for calculations
      var actualLineHeight = style.lineHeight === 'normal' ? lineHeight * parseFloat(style.fontSize) : parseFloat(style.lineHeight);
      var node = this._stage.firstChild.children ? this._stage.firstChild : this._stage;

      var nodeDataIndexes = [];
      var stringData = [];

      this._nodeMap = this.getNodeMap(node);

      for (var i = 0; i < this._nodeMap.length; i++) {
        var item = this._nodeMap[i];
        if (truncate === 'word' && item.data[item.data.length - 1] === ' ') {
          // remove random whitespace data between nodes
          item.data.length -= 1;
        }
        stringData[i] = item.data;
        for (var j = 0; j < item.data.length; j++) {
          // map each word or character datum index to its corresponding node
          nodeDataIndexes.push(i);
        }
      }

      this._defaultStringData = cloneArray(stringData);
      this._nodeDataIndexes = cloneArray(nodeDataIndexes);
      this._maxHeight = maxLines === 'auto' ? getBoundingClientRect(this._parent).height : maxLines * actualLineHeight;
      this._maxWidth = measureText(this._nodeMap.map(function (item) {
        return item.node;
      }), this._parent);
      this._maxLines = maxLines === 'auto' ? Math.round(this._maxHeight / actualLineHeight) : maxLines;
    }
  }, {
    key: 'getNodeMap',
    value: function getNodeMap(rootNode) {
      var truncate = this._options.truncate;

      var map = [];
      // parse child nodes and build a data map to associate each node with its data
      for (var i = 0; i < rootNode.childNodes.length; i++) {
        var node = rootNode.childNodes[i];
        if (node.nodeType === 1 || node.nodeType === 3) {
          var textContent = node.textContent + ' ';
          map.push({
            node: node,
            data: truncate === 'word'
            // eslint-disable-next-line no-useless-escape
            ? textContent.match(/.*?[\.\s\/]+?/g) : node.textContent.split('')
          });
        }
      }

      return map;
    }
  }, {
    key: 'getNodeIndexes',
    value: function getNodeIndexes(data) {
      var nodeDataIndexes = [];
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          nodeDataIndexes.push([i, j]);
        }
      }
      return nodeDataIndexes;
    }
  }, {
    key: 'domString',
    value: function domString(data) {
      var keys = Object.keys(data);
      var html = '';

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var mapItem = this._nodeMap[key];
        var text = data[key].join('');

        if (mapItem.node.nodeType === 1) {
          var name = mapItem.node.nodeName;
          var attr = mapItem.node.attributes;
          var attributes = '';
          for (var j = 0; j < attr.length; j++) {
            var att = attr[j];
            attributes += ' ' + att.nodeName + '="' + att.nodeValue + '"';
          }
          html += '<' + name + attributes + '>' + text + '</' + name + '>';
        } else if (mapItem.node.nodeType === 3) {
          html += text;
        }
      }
      return html;
    }
  }, {
    key: 'checkFit',
    value: function checkFit(data) {
      var html = this.domString(data);
      var node = this._options.maxLines === 'auto' ? this._stage : this._parent;
      var fits = true;
      this._stage.innerHTML = html;
      // allow a 0.5 px margin of error for browser calculation discrepancies
      if (getBoundingClientRect(node).height - this._maxHeight > 0.5) {
        fits = false;
      }

      return fits;
    }
  }, {
    key: 'truncate',
    value: function truncate() {
      var _options2 = this._options,
          ellipsis = _options2.ellipsis,
          ignore = _options2.ignore,
          position = _options2.position;

      var middle = position === 'middle';

      var truncated = false;
      var fits = false;
      var nodeIndex = 0;
      var dataIndex = 0;
      var truncatedText = '';
      var stringData = null;
      var remove = null;

      if (!this._stage) {
        return;
      }

      stringData = cloneArray(this._defaultStringData);
      dataIndex = middle ? 0 : this._nodeDataIndexes.length - 1;

      while (!fits) {
        if (dataIndex < 0) {
          break;
        }

        if (middle) {
          // as data is removed from the middle of our set, the node order could
          // change each iteration, so we need to keep updating a node index matrix
          // based on the current string data
          var matrix = this.getNodeIndexes(stringData);
          var center = Math.floor(matrix.length / 2);
          // the node index and word index to remove
          remove = matrix[center];
          if (dataIndex > 0) {
            // remove word/character currently in the center
            stringData[remove[0]].splice(remove[1], 1, ellipsis);
          }
        } else {
          nodeIndex = this._nodeDataIndexes[dataIndex];
          if (dataIndex < this._nodeDataIndexes.length - 1) {
            stringData[nodeIndex] = stringData[nodeIndex].slice(0, -1);
            stringData[nodeIndex].push(ellipsis);
          }
        }
        // test new data
        fits = this.checkFit(stringData);

        if (fits) {
          for (var i = 0; i < stringData.length; i++) {
            var data = stringData[i];
            truncatedText += data.join('');
          }
          break;
        } else {
          truncated = true;
          if (middle) {
            // remove ellipsis before re-testing
            stringData[remove[0]].splice(remove[1], 1);
            dataIndex++;
          } else {
            stringData[nodeIndex] = stringData[nodeIndex].slice(0, -1);
            dataIndex--;
          }
        }
      }

      stringData = cleanData(stringData, this._options, true);

      if (truncated && !middle) {
        truncatedText = cleanString(truncatedText.split(ellipsis)[0], ignore, false, true, true);
        truncatedText += ellipsis;
      } else if (truncated && middle) {
        var halves = truncatedText.split(ellipsis);
        truncatedText = cleanString(halves[0], ignore, false, true, true) + ellipsis + cleanString(halves[1], ignore, true, false, true);
      }

      return {
        isTruncated: truncated,
        text: truncatedText,
        data: stringData,
        constraints: {
          width: this._maxWidth,
          height: this._maxHeight,
          lines: this._maxLines
        }
      };
    }
  }]);

  return Truncator;
}();

export { Truncator as default };